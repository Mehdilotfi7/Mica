var documenterSearchIndex = {"docs":
[{"location":"references.html#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"references.html#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"references.html#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"references.html","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"references.html#TSCPDetector.AbstractModelSpec","page":"Reference","title":"TSCPDetector.AbstractModelSpec","text":"Abstract base type for all model specifications.\n\n\n\n\n\n","category":"type"},{"location":"references.html#TSCPDetector.DifferenceModelSpec","page":"Reference","title":"TSCPDetector.DifferenceModelSpec","text":"Specification for a discrete Difference Equation model.\n\nFields\n\nmodel_function::Function: A function that defines the difference dynamics.\nparams::Dict{Symbol, Any}: Parameters needed for the model.\ninitial_conditions::Float64: Initial state of the system.\nnum_steps::Int: Number of time steps for the simulation.\nextra_data::Tuple{Vector{Float64}, Vector{Float64}}: Additional inputs (e.g., external variables).\n\n\n\n\n\n","category":"type"},{"location":"references.html#TSCPDetector.ModelManager","page":"Reference","title":"TSCPDetector.ModelManager","text":"ModelManager{T<:AbstractModelSpec}\n\nA wrapper around any model specification (ODE, Difference, or Regression) that provides a unified interface to:\n\nAccess the initial condition\nSegment model-specific data for a given intervalyes\nGenerate per-segment models with updated parameters\nIdentify the model type for dispatching logic\n\nThis allows the objective function and other algorithms to remain model-agnostic.\n\n\n\n\n\n","category":"type"},{"location":"references.html#TSCPDetector.ODEModelSpec","page":"Reference","title":"TSCPDetector.ODEModelSpec","text":"Specification for an ODE (Ordinary Differential Equation) model.\n\nFields\n\nmodel_function::Function: A function that defines the ODE dynamics.\nparams::Dict{Symbol, Any}: Parameters needed for the model.\ninitial_conditions::Vector{Float64}: Initial conditions for the ODE system.\ntspan::Tuple{Float64, Float64}: Time span over which to simulate the model.\n\n\n\n\n\n","category":"type"},{"location":"references.html#TSCPDetector.RegressionModelSpec","page":"Reference","title":"TSCPDetector.RegressionModelSpec","text":"Specification for a simple Regression model (e.g., linear).\n\nFields\n\nmodel_function::Function: A function that defines the regression output.\nparams::Dict{Symbol, Any}: Parameters needed for the model.\ntime_steps::Int: Number of time steps or observations.\n\n\n\n\n\n","category":"type"},{"location":"references.html#TSCPDetector.BIC_penalty-Tuple{Any, Any}","page":"Reference","title":"TSCPDetector.BIC_penalty","text":"BIC_penalty(p, n)\n\nBayesian Information Criterion-style penalty.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.call_penalty_fn-Tuple{Function}","page":"Reference","title":"TSCPDetector.call_penalty_fn","text":"call_penalty_fn(f::Function; kwargs...) -> Real\n\nSafely call a user-provided penalty function f with only the arguments it accepts, using the last defined method of fn.\n\nThis allows users to define custom penalty functions that take any subset of the following:\n\np: number of segment-specific parameters\nn: total data length\nCP: vector of change points\nsegment_lengths: vector of segment lengths (computed as diff([0; CP; n]))\nnum_segments: number of segments (length(CP) + 1)\n\nImportant Note\n\nDue to Julia's multiple dispatch behavior, defining multiple methods for the same function name accumulates methods rather than replacing them. This means:\n\ncall_penalty_fn uses the last method returned by methods(fn).\nTo test different penalty functions, use different function names  (e.g., my_penalty1, my_penalty2, my_penalty3) to avoid ambiguity.\n\nExamples\n\n```julia my_penalty(p, n) = 2 * p * log(n)\n\ncallpenaltyfn(mypenalty;     p=3, n=250, CP=[50, 100], segmentlengths=[50, 50, 150], num_segments=3 )\n\n=> 33.21\n\nMore complex example: function imbalancepenalty(p, n, CP)     seglengths = diff([0; CP; n])     imbalance = std(seg_lengths)     return 3.3 * p * length(CP) * log(n) + 0.12 * imbalance end\n\ncallpenaltyfn(imbalancepenalty;     p=3, n=250, CP=[60, 130], segmentlengths=[60, 70, 120], num_segments=3 ) If the user omits some arguments, only those required by their function are passed.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.default_penalty-Tuple{Any, Any}","page":"Reference","title":"TSCPDetector.default_penalty","text":"default_penalty(p, n)\n\nA basic penalty proportional to BIC.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.detect_changepoints","page":"Reference","title":"TSCPDetector.detect_changepoints","text":"detect_changepoints(\n    objective_function, n, n_global, n_segment_specific, parnames,\n    model_manager, loss_function, data,\n    initial_chromosome, bounds, ga, min_length, step; pen=log(n)\n)\n\nDetect optimal change points using a greedy search strategy and regularized loss.\n\nReturns:\n\nVector of change point indices (CP)\nBest parameter vector found\n\n\n\n\n\n","category":"function"},{"location":"references.html#TSCPDetector.evaluate_segment-Tuple{Any, Int64, Int64, Vector{Int64}, Any, Vector{Float64}, Any, Any, Int64, Int64, Int64, Int64, Int64, ModelManager, Function, Matrix{Float64}, Function}","page":"Reference","title":"TSCPDetector.evaluate_segment","text":"evaluate_segment(...)\n\nEvaluate candidate change points in a segment [a, b] by inserting change points and computing the new loss for each.\n\nReturns a tuple of loss values and corresponding best chromosomes.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.example_difference_model-NTuple{4, Any}","page":"Reference","title":"TSCPDetector.example_difference_model","text":"Example: Discrete difference equation model.\n\nSimulates a difference equation influenced by external variables.\n\nArguments\n\nparams::Dict: Model parameters.\ninitial_conditions::Float64: Initial state.\nnum_steps::Int: Number of steps.\nextra_data::Tuple: (windspeeds, ambienttemperatures).\n\nReturns\n\nDataFrame: Time and state variable evolution.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.example_regression_model-Tuple{Any, Int64}","page":"Reference","title":"TSCPDetector.example_regression_model","text":"Example: Simple linear regression model.\n\nSimulates a linear trend y = a * t + b.\n\nArguments\n\nparams::Dict: Model parameters, expects :a and :b.\ntime_steps::Int: Number of time steps.\n\nReturns\n\nDataFrame: Time and simulated values.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.exponential_ode_model-Tuple{Any, Any, Any}","page":"Reference","title":"TSCPDetector.exponential_ode_model","text":"Example: Simple exponential decay ODE model.\n\nDefines the dynamics du/dt = -p * u.\n\nArguments\n\nparams::Dict: Model parameters, expects key :p.\ntspan::Tuple: (starttime, endtime).\nu0::Vector{Float64}: Initial condition vector.\n\nReturns\n\nMatrix: state variable evolution.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.extract_parameters-Union{Tuple{T}, Tuple{Vector{T}, Int64, Int64}} where T","page":"Reference","title":"TSCPDetector.extract_parameters","text":"extract_parameters(chromosome, n_global, n_segment_specific)\n\nSplits a chromosome vector into global and segment-specific parameters.\n\nArguments\n\nchromosome: Flat vector of all parameters.\nn_global: Number of global parameters.\nn_segment_specific: Number of segment parameters for each segment.\n\nReturns\n\n(global_parameters, segment_parameters)\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.get_initial_condition-Tuple{ModelManager{ODEModelSpec}}","page":"Reference","title":"TSCPDetector.get_initial_condition","text":"get_initial_condition(manager::ModelManager) -> Any\n\nReturns the initial condition used by the model. For:\n\nODE models: returns the vector of initial states.\nDifference models: returns the scalar initial value.\nRegression models: returns nothing (no initial condition concept).\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.get_model_type-Tuple{ModelManager{ODEModelSpec}}","page":"Reference","title":"TSCPDetector.get_model_type","text":"get_model_type(manager::ModelManager) -> String\n\nReturns a string identifier for the model type: \"ODE\", \"Difference\", or \"Regression\". Useful for logging or conditional logic.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.objective_function-Tuple{Any, Any, Any, Int64, Int64, ModelManager, Function, Matrix{Float64}}","page":"Reference","title":"TSCPDetector.objective_function","text":"objective_function(...)\n\nComputes the total loss for the current chromosome, simulating each segment separately.\n\nArguments\n\nchromosome: The vector of model parameters (includes global and segment-specific).\nchange_points: Vector of indices defining segmentation boundaries.\nn_global: Number of global parameters.\nn_segment_specific: Number of parameters specific to each segment.\nextract_parameters: A function that extracts global and per-segment parameters from the chromosome.\nparnames: Names of the model parameters (used to construct LArray or Dict).\nmodel_manager: An instance of ModelManager, holding model type and base config.\nsimulate_model: A function to simulate the model (multi-dispatch on model type).\nloss_function: Loss function applied to a single segment.\nsegment_loss: Function that computes the loss given true vs simulated data using loss_function.\ndata: The full observed data (e.g., vector, matrix, or tuple of vectors).\n\nReturns\n\nTotal loss across all segments.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.optimize_with_changepoints-Tuple{Any, Any, Any, Any, Any, Any, Any, Any, ModelManager, Function, Matrix{Float64}}","page":"Reference","title":"TSCPDetector.optimize_with_changepoints","text":"optimize_with_changepoints(\n    objective_function, chromosome, CP, bounds, ga,\n    n_global, n_segment_specific, parnames,\n    model_manager, loss_function, data; options=...\n)\n\nOptimize model parameters for a fixed set of change points using Evolutionary.jl.\n\nReturns the minimum loss and the best parameter set.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.segment_model-Tuple{ModelManager{ODEModelSpec}, Any, Int64, Int64, Any}","page":"Reference","title":"TSCPDetector.segment_model","text":"segment_model(manager, seg_pars, parnames, idx_start, idx_end, u0) -> AbstractModelSpec\n\nBuilds a new per-segment model specification using:\n\nThe segment-specific parameters seg_pars and their names parnames\nThe index range [idx_start:idx_end] defining the segment\nThe initial condition u0 passed from the last segment\n\nDispatches based on model type to slice and prepare data correctly.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.simulate_model-Tuple{DifferenceModelSpec}","page":"Reference","title":"TSCPDetector.simulate_model","text":"Simulates a DifferenceModelSpec by iterating the discrete equation.\n\nArguments\n\nmodel::DifferenceModelSpec: A Difference model specification.\n\nReturns\n\nSimulated results over discrete time steps.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.simulate_model-Tuple{ODEModelSpec}","page":"Reference","title":"TSCPDetector.simulate_model","text":"Simulates an ODEModelSpec by solving the ODE system.\n\nArguments\n\nmodel::ODEModelSpec: An ODE model specification.\n\nReturns\n\nSimulated results over time.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.simulate_model-Tuple{RegressionModelSpec}","page":"Reference","title":"TSCPDetector.simulate_model","text":"Simulates a RegressionModelSpec by evaluating the regression model.\n\nArguments\n\nmodel::RegressionModelSpec: A Regression model specification.\n\nReturns\n\nSimulated outputs.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.update_bounds!-NTuple{5, Any}","page":"Reference","title":"TSCPDetector.update_bounds!","text":"update_bounds!(chromosome, bounds, n_global, n_segment_specific, extract_parameters)\n\nUpdate bounds and chromosome by appending segment-specific parameters.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.update_initial_condition-Tuple{ModelManager{ODEModelSpec}, Any}","page":"Reference","title":"TSCPDetector.update_initial_condition","text":"update_initial_condition(manager::ModelManager, sim_data::DataFrame)\n\nReturns the updated initial condition for the next segment based on the output of the last segment's simulation.\n\n\n\n\n\n","category":"method"},{"location":"references.html#TSCPDetector.wrapped_obj_function-Tuple{Any}","page":"Reference","title":"TSCPDetector.wrapped_obj_function","text":"wrapped_obj_function(chromosome)\n\nConvenient closure to call objective_function with fixed outer parameters.\n\n\n\n\n\n","category":"method"},{"location":"getting_started.html#Getting-Started","page":"Getting started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"Once you've installed and loaded Mocha.jl, you're ready to begin modeling and detecting changepoints.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"getting_started.html#First-Steps","page":"Getting started","title":"First Steps","text":"","category":"section"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"Try a simple built-in model using the simulate_model function:","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"using Mocha\n\nmodel = exponential_ode_model()\nsol = simulate_model(model)","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"This simulates a basic exponential decay model defined by an ordinary differential equation (ODE), using default parameters and initial conditions.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"getting_started.html#Core-Workflow","page":"Getting started","title":"Core Workflow","text":"","category":"section"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"A typical workflow in Mocha.jl looks like this:","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"Define or select a model Use one of the built-in examples (exponential_ode_model, example_difference_model, etc.) or define your own model structure using the provided ODEModelSpec, DifferenceModelSpec, or RegressionModelSpec types.\nSimulate the model Use simulate_model(model) to generate synthetic or fitted outputs.\nFormat data and objective Prepare your observed data in a matrix format and define a loss function to quantify the difference between model predictions and data.\nRun changepoint detection Use detect_changepoints(...) to estimate both the changepoint locations and the model parameters in each segment. The algorithm applies evolutionary optimization to jointly minimize the simulation error and a penalty function.","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"getting_started.html#Next-Steps","page":"Getting started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"To learn more:","category":"page"},{"location":"getting_started.html","page":"Getting started","title":"Getting started","text":"Explore Tutorials: Guided examples for ODEs and discrete systems\nReview Problem Types: Understand which models are supported\nTry Examples Realistic use cases and model setups\nSee Reference: API documentation for all core types and functions","category":"page"},{"location":"problems.html#Supported-Problem-Types","page":"Problem types","title":"Supported Problem Types","text":"","category":"section"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"Mocha.jl is designed to detect changepoints in model-based time series. Instead of relying on statistical shifts (e.g., mean/variance), Mocha tracks changes in the parameters of an explicit model.","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"This section outlines the types of models currently supported by the package.","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"","category":"page"},{"location":"problems.html#Model-Categories","page":"Problem types","title":"Model Categories","text":"","category":"section"},{"location":"problems.html#1.-**Ordinary-Differential-Equation-(ODE)-Models**","page":"Problem types","title":"1. Ordinary Differential Equation (ODE) Models","text":"","category":"section"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"These models describe the system as a set of continuous-time equations:","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"Suitable for: epidemiology, population dynamics, physics-based systems\nRequires: a function defining the ODE, a time span (t₀, t₁), and initial conditions","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"struct ODEModelSpec <: AbstractModelSpec\n    model_function::Function\n    params\n    initial_conditions::Vector{Float64}\n    tspan::Tuple{Float64, Float64}\nend","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"Use when your system evolves continuously and smoothly over time.","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"","category":"page"},{"location":"problems.html#2.-**Difference-Equation-Models**","page":"Problem types","title":"2. Difference Equation Models","text":"","category":"section"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"These simulate discrete-time systems where the state evolves via recurrence relations.","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"Suitable for: digital control systems, econometrics, thermal systems\nRequires: initial value, number of steps, external inputs (optional)","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"struct DifferenceModelSpec <: AbstractModelSpec\n    model_function::Function\n    params\n    initial_conditions::Float64\n    num_steps::Int\n    extra_data::Tuple{Vector{Float64}, Vector{Float64}}\nend","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"Use when the system is updated at regular discrete time intervals.","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"","category":"page"},{"location":"problems.html#3.-**Regression-Models**","page":"Problem types","title":"3. Regression Models","text":"","category":"section"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"Simple predictive models based on a parametric function.","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"Suitable for: trend fitting, linear/nonlinear regression, control baselines\nRequires: a function, number of time steps, and parameters","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"struct RegressionModelSpec <: AbstractModelSpec\n    model_function::Function\n    params\n    time_steps::Int\nend","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"Use for interpretable baselines or when data relationships are simple but nonlinear.","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"","category":"page"},{"location":"problems.html#Future-Extensions","page":"Problem types","title":"Future Extensions","text":"","category":"section"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"While the current version focuses on ODEs, difference, and regression models, Mocha.jl is designed to be extensible.","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"Planned or possible extensions include:","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"State-space models (e.g., Kalman filters)\nAgent-based models\nHybrid continuous/discrete systems\nNeural differential equations","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"If you'd like to contribute new model types or request support, visit the GitHub repository.","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"","category":"page"},{"location":"problems.html","page":"Problem types","title":"Problem types","text":"Next: Learn how to define and simulate your own model in the Tutorials section.","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This page provides illustrative examples demonstrating how to use Mocha.jl for changepoint detection across a range of domains. Before you go through this page, we recommend you to first familirize yoursef with the algorithm in Tutorial: Understanding Mocha's Changepoint Detection Algorithm page.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples.html#Working-with-functions","page":"Examples","title":"Working with functions","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Statistics # hide\nx=1","category":"page"},{"location":"examples.html#Example-1:-Toy-SIR-Model-with-Synthetic-Data","page":"Examples","title":"Example 1: Toy SIR Model with Synthetic Data","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example demonstrates detecting changepoints in a simple SIR (Susceptible-Infectious-Recovered) epidemic model with synthetic data. The infection rate (β) changes at specific points in time.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Evolutionary, DifferentialEquations, LabelledArrays, Plots, Statistics, Random\n\n# Define the SIR model dynamics\nfunction sirmodel!(du, u, p, t)\n    S, I, R = u\n    β, γ = p\n    du[1] = -β * S * I\n    du[2] = β * S * I - γ * I\n    du[3] = γ * I\nend\n\n# Generate synthetic data with changepoints\nfunction generate_toy_dataset(beta_values, change_points, γ, u0, tspan, noise_level, noise)\n    data_CP = []\n    all_times = []\n    for i in 1:length(change_points)+1\n        tspan_segment = i == 1 ? (0.0, change_points[i]) :\n                        i == length(change_points)+1 ? (change_points[i-1]+1.0, tspan[2]) :\n                        (change_points[i-1]+1.0, change_points[i])\n        params = @LArray [beta_values[i], γ] (:β, :γ)\n        prob = ODEProblem(sirmodel!, u0, tspan_segment, params)\n        sol = solve(prob, saveat = 1.0)\n        data_CP = vcat(data_CP, sol[2,:] + noise_level * noise(length(sol.t)))\n        all_times = vcat(all_times, sol.t)\n        u0 = sol.u[end]\n    end\n    return all_times, abs.(data_CP)\nend\n\n# Setup parameters\nβ_values = [0.00009, 0.00014, 0.00025, 0.0005]\nchange_points_true = [50, 100, 150]\nγ = 0.7\nu0 = [9999.0, 1.0, 0.0]\ntspan = (0.0, 160.0)\nRandom.seed!(1234)\nnoise_level = 20\nnoise = randn\n\n# Generate data and reshape\n_, data = generate_toy_dataset(β_values, change_points_true, γ, u0, tspan, noise_level, noise)\ndata_M = reshape(Float64.(data), 1, :)\nplot(data_M[1, :])\n\n# Redefine model with named parameters\nfunction sirmodel!(du, u, p, t)\n    S, I, R = u\n    β, γ = p.β , p.γ\n    du[1] = -β * S * I\n    du[2] = β * S * I - γ * I\n    du[3] = γ * I\nend\n\n# Wrapper for Mocha\nfunction example_ode_model(params, tspan::Tuple{Float64, Float64}, u0::Vector{Float64})\n    prob = ODEProblem(sirmodel!, u0, tspan, params)\n    sol = solve(prob, Tsit5(), saveat=1.0, abstol = 1.0e-6, reltol = 1.0e-6)\n    return sol[:, :]\nend\n\n# Loss function for fitting\nfunction loss_function(observed, simulated)\n    simulated = simulated[2:2, :]\n    return sqrt(sum(abs2, (observed .- simulated).^2))\nend\n\n# Prepare model and settings\ninitial_chromosome = [0.69, 0.0002]\nparnames = (:γ, :β)\nbounds = ([0.1, 0.0], [0.9, 0.1])\nu0 = [9999.0, 1.0, 0.0]\nmodel_spec = ODEModelSpec(example_ode_model, initial_chromosome, u0, tspan)\nmodel_manager = ModelManager(model_spec)\nn_global, n_segment_specific = 1, 1\nmin_length, step = 10, 10\nga = GA(populationSize=150, selection=uniformranking(20),\n        crossover=MILX(0.01, 0.17, 0.5), mutationRate=0.3,\n        crossoverRate=0.6, mutation=gaussian(0.0001))\nmy_penalty(p, n) = 10.0 * p * log(n)\nn = length(data_M)\n\n# Detect changepoints\ndetected_cp, params = detect_changepoints(\n    objective_function,\n    n, n_global, n_segment_specific,\n    model_manager,\n    loss_function,\n    data_M,\n    initial_chromosome, parnames, bounds, ga,\n    min_length, step, my_penalty\n)\n","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"(Image: First Example)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples.html#Example-2:-COVID-19-Intervention-Detection-in-Germany","page":"Examples","title":"Example 2: COVID-19 Intervention Detection in Germany","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"This example demonstrates Mocha's application for analyzing the effects of governmental interventions during the COVID-19 pandemic in Germany.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The model includes:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"11 state variables including: susceptible, multiple stages of infection, deaths, recovered, and vaccination.\n8 segment-specific parameters re-estimated for each detected segment.\n8 global parameters re-optimized after each new changepoint is detected.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"The objective function uses five observational signals:","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Infected\nHospitalized\nICU admissions\nDeaths\nVaccination","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"A logarithmic transformation is applied to each signal before loss computation to normalize the magnitude of variation. The optimization and detection pipeline uses a tailored genetic algorithm and domain-informed parameter bounds.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"After executing the Mocha changepoint detection routine, most of the inferred changepoints corresponded to known intervention periods, such as lockdowns or vaccination policy shifts. This result affirms Mocha’s practical utility for epidemiological modeling and policy evaluation.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"📌 Note: Due to the use of real datasets, this example requires importing and pre-processing COVID-19 time series data from official RKI sources (CSV files).","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We begin by defining an ODE-based epidemiological model for simulating the spread of COVID-19. To account for seasonal variation in transmission rates, a seasonality function is incorporated directly into the infection dynamics. The model is then wrapped with a solver function using the DifferentialEquations.jl package, which allows for accurate and efficient numerical integration.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Evolutionary \nusing DifferentialEquations\nusing LabelledArrays\nusing Plots\nusing Statistics\nusing Random\nusing CSV\nusing DataFrames\n\n# seasonal factor\nfunction fδ(t::Number, δ::Number, t₀::Number=0.0)\n    return 1 + δ*cos(2*π*((t - t₀)/365))\nend\n\nfunction log_transform(data, threshold=1e-3)\n    return [val > threshold ? log(val) : val for val in data]\nend\n\n# ODE model\nfunction CovModel!(du,u,p,t)\n    (ᴺS, ᴺE₀, ᴺE₁, ᴺI₀, ᴺI₁, ᴺI₂, ᴺI₃,ᴺR, D, Cases, V) = u[1:11]\n    N = ᴺS + ᴺE₀ + ᴺE₁ + ᴺI₀ + ᴺI₁ + ᴺI₂ + ᴺI₃ + ᴺR + D\n\n    ᴺε₀  = p.ᴺε₀\n    ᴺε₁  = p.ᴺε₁\n    ᴺγ₀  = p.ᴺγ₀\n    ᴺγ₁  = p.ᴺγ₁\n    ᴺγ₂  = p.ᴺγ₂\n    ᴺγ₃  = p.ᴺγ₃ \n    ᴺp₁  = p.ᴺp₁ \n    ᴺp₁₂ = p.ᴺp₁₂ \n    ᴺp₂₃ = p.ᴺp₂₃\n    ᴺp₁D = p.ᴺp₁D\n    ᴺp₂D = p.ᴺp₂D\n    ᴺp₃D = p.ᴺp₃D\n    δ    = p.δ\n    δₜ = fδ(t,δ)\n    ᴺβ   = p.ᴺβ  \n    ω    = p.ω \n    ν = t < 330 ? 0 : p.ν\n\n    ᴺβᴺSI = ᴺβ * δₜ * ᴺS * (ᴺE₁ + ᴺI₀ + ᴺI₁)\n    du[1]  = - (ᴺβᴺSI)/N + ω * ᴺR - ν * ᴺS\n    du[2]  =  (ᴺβᴺSI/N) - (ᴺε₀ * ᴺE₀)\n    du[3]  =  (ᴺε₀ * ᴺE₀) - (ᴺε₁ * ᴺE₁)\n    du[4]  =  ((1 - ᴺp₁) * ᴺε₁ * ᴺE₁) - (ᴺγ₀ * ᴺI₀)\n    du[5]  =  (ᴺp₁ * ᴺε₁ * ᴺE₁) - (ᴺγ₁ * ᴺI₁)\n    du[6]  =  (ᴺp₁₂ * ᴺγ₁ * ᴺI₁) - (ᴺγ₂ * ᴺI₂)\n    du[7]  =  (ᴺp₂₃ * ᴺγ₂ * ᴺI₂) - (ᴺγ₃ * ᴺI₃)\n    du[8]  =  ᴺγ₀ * ᴺI₀ + (1 - ᴺp₁₂ - ᴺp₁D) * ᴺγ₁ * ᴺI₁ + (1 - ᴺp₂₃ - ᴺp₂D) * ᴺγ₂ * ᴺI₂ +(1 - ᴺp₃D)* ᴺγ₃ * ᴺI₃ - ω * ᴺR + ν * ᴺS\n    du[9]  =  (ᴺp₁D * ᴺγ₁ * ᴺI₁) + (ᴺp₂D * ᴺγ₂ * ᴺI₂) + (ᴺp₃D * ᴺγ₃ * ᴺI₃)\n    du[10] =  (ᴺp₁ * ᴺε₁ * ᴺE₁)\n    du[11] =  ν * ᴺS\nend\n\nfunction example_ode_model(params, tspan::Tuple{Float64, Float64}, u0::Vector{Float64})\n    prob = ODEProblem(CovModel!, u0, tspan, params)\n    sol = solve(prob, Tsit5(), saveat=1.0, abstol = 1.0e-6, reltol = 1.0e-6,\n                isoutofdomain = (u,p,t)->any(x->x<0,u))\n    return sol[:,:]\nend\n","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Next, we define a customized loss function to evaluate the discrepancy between the observed data and model simulations for each segment. A logarithmic transformation is applied to each data stream prior to loss calculation. This transformation helps stabilize variance, downweight large values, and emphasize relative changes—an important consideration when dealing with epidemiological time series that span multiple orders of magnitude.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"\nfunction loss_function(observed, simulated)\n    infected =  simulated[5,:]\n    hospital =  simulated[6,:]\n    icu      =  simulated[7,:]\n    death    =  simulated[9,:]\n    vacc     =  simulated[11,:] \n    return sum(abs, log_transform(infected).- log_transform(observed[1])) +\n           sum(abs, log_transform(hospital).- log_transform(observed[2])) +\n           sum(abs, log_transform(icu).- log_transform(observed[3])) +\n           sum(abs, log_transform(death).- log_transform(observed[4])) +\n           sum(abs, log_transform(vacc).- log_transform(observed[5]))\nend","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We then load real-world COVID-19 data obtained from the official RKI (Robert Koch Institute) GitHub repository. This dataset includes daily records of confirmed cases, hospitalizations, ICU admissions, deaths, and vaccinations in Germany. The signals are smoothed and aligned to ensure consistent segment lengths before being passed to the changepoint detection algorithm.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"\ncd(dirname(@__FILE__))\ncases_CP = CSV.read(\"case_rki_daily.csv\", DataFrame)\ncases_CP_date = cases_CP.date\ncases_CP = cases_CP.total\nhospital_CP = CSV.read(\"Hospitalization_rki_daily.csv\", DataFrame)\nhospital_CP = hospital_CP.total\ndeath_CP = CSV.read(\"death_rki_daily.csv\", DataFrame)\ndeath_CP = cumsum(death_CP.Todesfaelle_neu)\nicu_CP = CSV.read(\"icu_rki_daily.csv\", DataFrame)\nicu_CP = icu_CP.total\nvacc_CP = CSV.read(\"vaccination_rki_daily_allShots.csv\", DataFrame)\nvacc_CP = cumsum(vacc_CP.Total)\n\ndata_CP = [cases_CP, hospital_CP, icu_CP, death_CP, vacc_CP]\nmax_length = maximum(length, data_CP)\n\nusing Smoothers\ndata_CP = [vcat(zeros(Int, max_length - length(data)), data) for data in data_CP]\ndata_CP = [vector[1:400] for vector in data_CP]\ndata_CP[1] = hma(data_CP[1], 21)\ndata_CP[4] = hma(data_CP[4], 21)\ndata_CP[5] = hma(data_CP[5], 21)\ndata_CP = reduce(hcat, data_CP)'\ndata_CP = Matrix(data_CP)","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Finally, we configure and call the changepoint detection function. This step identifies the most likely change points in the time series and estimates both the global (constant across segments) and segment-specific parameters. The result is a single vector of estimated parameters, structured such that the global parameters appear first, followed sequentially by the segment-specific parameters for each detected segment.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"\nparnames = (:ω, :δ, :ᴺε₀, :ᴺε₁, :ᴺγ₀, :ᴺγ₁, :ᴺγ₂, :ᴺγ₃, :ᴺp₁, :ᴺβ,:ᴺp₁₂, :ᴺp₂₃, :ᴺp₁D, :ᴺp₂D, :ᴺp₃D, :ν)\ninitial_chromosome = [0.1, 1/7, 1/11.4, 1/14, 1/13.4, 1/9, 1/16, 0.0055, 0.2, 0.05, 0.17, 0.144, 0.01, 0.017, 0.173, 0.01]\nlower =              [0.1, 1/10, 1/11.7, 1/24, 1/15.8, 1/19, 1/27, 0.003, 0.0, 0.0, 0.001, 0.001, 0.001, 0.001, 0.001, 10e-5]\nupper =              [0.3, 1/3,  1/11.2, 1/5,  1/10.9, 1/5,  1/8,  0.012, 0.8, 8.0, 0.5,   0.5,   0.5,   0.5,   0.5,   0.1]\nbounds = (lower, upper)\nN = 83129285 # German population\nu0 = [N-1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]\ntspan = (0.0, 399.0)\node_spec = ODEModelSpec(example_ode_model, initial_chromosome, u0, tspan)\nmodel_manager = ModelManager(ode_spec)\nn_global = 8\nn_segment_specific = 8\nmin_length = 10\nstep = 10\nga = GA(populationSize = 100, selection = tournament(2), crossover = SBX(0.7, 1), mutationRate=0.7,\n        crossoverRate=0.7, mutation = gaussian(0.0001))\nn = size(data_CP,2)\nmy_penalty4(p, n) = 10.0 * p * log(n)\n\ndetected_cp, params = detect_changepoints(\n    objective_function,\n    n, n_global, n_segment_specific,\n    model_manager,\n    loss_function,\n    data_CP,\n    initial_chromosome, parnames, bounds, ga,\n    min_length, step\n)\n","category":"page"},{"location":"examples.html#Example-3:-Wind-Turbine-Performance-using-DE","page":"Examples","title":"Example 3: Wind Turbine Performance using DE","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Coming soon...","category":"page"},{"location":"examples.html#Example-4:-ECG-Signal-Analysis-using-ARIMA","page":"Examples","title":"Example 4: ECG Signal Analysis using ARIMA","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"Coming soon...","category":"page"},{"location":"loss_function.html#Custom-Loss-Functions-for-Segment-Evaluation","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"","category":"section"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"In Mocha, the cost of each segment is calculated using a loss function that compares the simulated model output to the observed data. This per-segment cost is then aggregated by the objective function, which drives changepoint detection and optimization.","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"This guide explains how to define and use custom loss functions within Mocha, how they are used in segment evaluation, and how they differ from the internal objective function.","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"","category":"page"},{"location":"loss_function.html#Segment-Loss-vs.-Global-Objective","page":"Custom Loss Functions for Segment Evaluation","title":"Segment Loss vs. Global Objective","text":"","category":"section"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"Loss Function: Computes the discrepancy between model predictions and real data within a single segment.\nObjective Function: Combines the segment losses, adds penalty terms (e.g. BIC), and evaluates the overall model fit across all segments.","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"This separation allows you to plug in domain-specific error measures for each segment while letting Mocha handle optimization at the global level.","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"","category":"page"},{"location":"loss_function.html#Defining-a-Custom-Loss-Function","page":"Custom Loss Functions for Segment Evaluation","title":"Defining a Custom Loss Function","text":"","category":"section"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"A loss function in Mocha must follow this interface:","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"function my_loss_function(sim_output::Vector, observed_data::Vector)::Float64","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"It should return a scalar loss value.","category":"page"},{"location":"loss_function.html#Example-1:-Mean-Squared-Error-(MSE)","page":"Custom Loss Functions for Segment Evaluation","title":"Example 1: Mean Squared Error (MSE)","text":"","category":"section"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"function mse_loss(sim, data)\n    return sum((sim .- data).^2)\nend","category":"page"},{"location":"loss_function.html#Example-2:-Logarithmic-Loss","page":"Custom Loss Functions for Segment Evaluation","title":"Example 2: Logarithmic Loss","text":"","category":"section"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"function log_loss(sim, data)\n    return sum(log.(abs.(sim .- data) .+ 1e-6))  # Avoid log(0)\nend","category":"page"},{"location":"loss_function.html#Example-3:-Normalized-RMSE","page":"Custom Loss Functions for Segment Evaluation","title":"Example 3: Normalized RMSE","text":"","category":"section"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"function nrmse_loss(sim, data)\n    rmse = sqrt(mean((sim .- data).^2))\n    return rmse / (maximum(data) - minimum(data))\nend","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"","category":"page"},{"location":"loss_function.html#Using-a-Custom-Loss-Function-in-Mocha","page":"Custom Loss Functions for Segment Evaluation","title":"Using a Custom Loss Function in Mocha","text":"","category":"section"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"To apply your custom loss during changepoint detection:","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"obj_fn = wrapped_obj_function(model, data, loss_fn = my_loss_function)","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"Then pass obj_fn to optimize_with_changepoints or other relevant calls.","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"This gives you full control over how error is computed for each segment while leveraging Mocha’s optimization engine.","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"","category":"page"},{"location":"loss_function.html#Additional-Notes","page":"Custom Loss Functions for Segment Evaluation","title":"Additional Notes","text":"","category":"section"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"The loss function should be efficient, as it's called frequently during GA optimization.\nMocha expects vector output from the model; ensure your simulation returns the correct shape.\nYou can log or visualize segment-wise losses for interpretability.","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"","category":"page"},{"location":"loss_function.html","page":"Custom Loss Functions for Segment Evaluation","title":"Custom Loss Functions for Segment Evaluation","text":"By customizing your loss function, you tailor the segmentation process to your modeling priorities — whether it's prediction accuracy, stability, or a domain-specific criterion.","category":"page"},{"location":"index.html#Mocha.jl-–-Model-Based-Changepoint-Analysis","page":"Home","title":"Mocha.jl – Model-Based Changepoint Analysis","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: TSCPDetector.jl)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Welcome to the documentation for Mocha.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Mocha.jl provides a robust and model-driven approach to changepoint detection in time series data. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#What-is-Mocha.jl?","page":"Home","title":"What is Mocha.jl?","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Mocha.jl provides a model-driven alternative to conventional changepoint detection methods. While most existing tools rely on detecting shifts in statistical properties (like the mean or variance), Mocha instead detects changes in system dynamics as reflected in model parameters.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This makes Mocha well-suited for:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Epidemiological modeling\nEngineering systems (e.g., thermal dynamics)\nEconomic and ecological simulations\nAny domain where a generative model describes the system's behavior","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Key-Features","page":"Home","title":"Key Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Model-Aware Detection: Integrates system models directly into the changepoint detection algorithm.\nSupports Multiple Model Types: (you can see more detaild explaination in Supported Problem Types page)\nODEs (Ordinary Differential Equations)\nDifference equations\nRegression-based models\n(Support for additional model types coming in future releases)\nEvolutionary Optimization: Uses genetic algorithms (via Evolutionary.jl) to estimate changepoints and parameters.\nCustomizable: Supply your own model, loss function, or penalty criteria.\nInterpretable Outputs: Detects not just where change happens, but what model parameters change.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"To install Mocha.jl, use the Julia package manager:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"Mocha\")","category":"page"},{"location":"index.html#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you use Mocha.jl in your research or applications, please cite the following paper:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Mehdi Lotfi, \"Mocha: Model-Based Changepoint Analysis\", [arXiv link or DOI].","category":"page"},{"location":"tutorial.html#Tutorial:-Understanding-Mocha's-Changepoint-Detection-Algorithm","page":"Tutorials","title":"Tutorial: Understanding Mocha's Changepoint Detection Algorithm","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"This tutorial provides a detailed, step-by-step walkthrough of Mocha's methodology for detecting changepoints in time series data. It is designed to help you understand not only how to use the package but also how the underlying algorithm works.","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"💡 Note: This tutorial is based on an ODE (Ordinary Differential Equation) model to illustrate the core concepts. However, the underlying methodology—segmentation, optimization, and changepoint detection—applies equally to all model types supported by Mocha.jl, including difference equations and regression models.","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorial.html#Overview","page":"Tutorials","title":"Overview","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Mocha detects changepoints in time-dependent systems by analyzing shifts in model parameters instead of raw statistical properties like mean or variance. The core idea is to fit a piecewise model where each segment has its own parameters, allowing detection of structural changes in the underlying system.","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorial.html#Methodological-Foundation","page":"Tutorials","title":"Methodological Foundation","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Mocha is designed around Piecewise Switching ODEs (PSODEs), where a time series is assumed to be governed by different parameter regimes across segments. It generalizes a standard ODE:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"fracdydt = f(ytp)","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"into a segmented system:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"fracdydt = sum_i=1^k + 1 mathbf1_t_i-1 leq t  t_i f_i(yt NSP SP_i)","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"NSP: Non-segment-specific parameters (global across all segments)\nSP_i: Segment-specific parameters for segment i\nt_i: Change points that separate the segments","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"The model guarantees continuity across segments by ensuring:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"y(t_i^-) = y(t_i^+)","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"This way, Mocha inherits the mathematical guarantees of traditional ODE theory within each segment.","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorial.html#Problem-Formulation","page":"Tutorials","title":"Problem Formulation","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Formally, Mocha formulates changepoint detection as a model selection problem:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"V(CPs y) = sum_i=1^k cleft(x_t_i-1 dots t_iright) + textpenalty","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Where:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"CPs: Change points to detect\nc(...): Cost function comparing model simulation vs. observed data in each segment\npenalty: Term to prevent overfitting (too many change points)","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorial.html#Architecture","page":"Tutorials","title":"Architecture","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"(Image: Mocha Flowchart)","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Algorithm Flowchart Summary: The algorithm follows a modular, iterative structure with three key blocks:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Block 1 – Optimization Module: Solves the model over the full data and calculates baseline cost assuming no change points.\nBlock 2 – Segmentation Module: Proposes potential change points using binary segmentation and evaluates candidate splits.\nBlock 3 – Chromosome Updating: If a change point improves model fit, the chromosome is updated to include new segment-specific parameters. The process continues until no further improvement is observed.","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"The algorithm consists of three modules:","category":"page"},{"location":"tutorial.html#1.-Segmentation-Module-(Propose-Candidates)","page":"Tutorials","title":"1. Segmentation Module (Propose Candidates)","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Uses a modified binary segmentation.\nScans the data from start to end (forward pass) and end to start (backward pass).\nEnsures each proposed segment satisfies minimum length constraints.","category":"page"},{"location":"tutorial.html#2.-Optimization-Module-(Validate-Candidates)","page":"Tutorials","title":"2. Optimization Module (Validate Candidates)","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Uses a genetic algorithm (GA) to optimize model parameters.\nThe GA evolves chromosomes representing the parameters.\nThe structure is updated as new change points are added.","category":"page"},{"location":"tutorial.html#3.-Interaction-Layer","page":"Tutorials","title":"3. Interaction Layer","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Orchestrates the process:\nEvaluates full model loss for proposed changepoints.\nIf a candidate improves fit (minus penalty), it is accepted.\nUpdates chromosome and restarts on new segments.","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorial.html#Chromosome-Structure-in-Optimization","page":"Tutorials","title":"Chromosome Structure in Optimization","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"The genetic algorithm uses a chromosome split into:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Global parameters (NSP)\nParameters for each segment (SP_i)","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"As new change points are added, the chromosome dynamically expands:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"[NSP | SP_1 | SP_2 | ... | SP_k]","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"The GA minimizes the sum of squared errors + penalty:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"sum_ksum_jsum_i(Data - Simulation)^2","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Updating chromosome bound and length is done by TSCPDetector.update_bounds! function.","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorial.html#Iterative-Process","page":"Tutorials","title":"Iterative Process","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Initialization:\nAssume no change points.\nOptimize global model using GA.\nSegmentation Proposals:\nSweep the current segment with a window.\nTry introducing a change point at each valid j.\nEvaluation:\nRun GA for each candidate segment split.\nIf adding a change point reduces loss significantly, accept it.\nChromosome Update:\nExpand the chromosome.\nRe-optimize.\nRepeat:\nRecurse into new segments using updated change points.\nStop when no more beneficial change points can be found.","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorial.html#Penalty-Functions","page":"Tutorials","title":"Penalty Functions","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"To avoid overfitting, Mocha uses customizable penalty functions. Some built-in examples:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"default_penalty(p, n) = 2 * p * log(n)\nimbalance_penalty(p, n, CP) penalizes unbalanced segment lengths.","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Users can define their own functions and pass them into the API.","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"","category":"page"},{"location":"tutorial.html#Summary","page":"Tutorials","title":"Summary","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Mocha is built to detect true structural changes in modeled time series systems. It:","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"Supports custom models (ODEs, Difference, Regression)\nDetects changepoints via shifts in model parameters\nUses evolutionary optimization for parameter fitting\nCan incorporate penalties and constraints for robust results","category":"page"},{"location":"tutorial.html","page":"Tutorials","title":"Tutorials","text":"The modular design ensures you can plug in your own models, loss functions, and penalty strategies while taking advantage of Mocha's powerful changepoint detection engine.","category":"page"}]
}
